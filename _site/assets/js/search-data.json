{
  "0": {
    "id": "0",
    "title": "",
    "content": "  404  Page not found :(  The requested page could not be found.",
    "url": "http://localhost:4000/monitor-api-doku/404.html",
    "relUrl": "/404.html"
  },
  "1": {
    "id": "1",
    "title": "Admin",
    "content": "Administrativer BereichZum jetzigen Zeitpunkt liegt die Funktionalität des Administrativen-Teils vor allem in der Pflege der OGC-Dienste. Über ein Dashboard können diese aktualisiert werden. In diesem Kapitel wird das Frontend und auch das Backend dokumentiert.",
    "url": "http://localhost:4000/monitor-api-doku/docs/admin",
    "relUrl": "/docs/admin"
  },
  "2": {
    "id": "2",
    "title": "Backend",
    "content": "Inhalt  routes.py          route(/user)      route(/login)      route(/signup)      route (/confirm/token)      route (/services)      route (/reset)      route (/reset/token)        Models          Mailer      User      Token        Sicherheit          URL-Manipulierung      SQL-Injektion        routes.py        Flask selbst ist kaum mehr als ein Bindeglied, das die WSGI-Schicht und die Template-Bibliothek zusammenhält. Insbesondere kümmert es sich um das sogenannte Routing, das URLs auf Funktionen abbildet. (admin-magazin)        route(/)        Dies ist die sogenannte Main-Route, hier wird lediglich aus dem Dateiorder user innerhalb des static-Verzeichnisses die index.html gerendert.        route(/user)        Mit der Funktion get_service() werden dem Nutzer die OGC-Dienste über die API bereitgestellt. Über einen GET request müssen die URL-Parameter an den Endpoint gesendet werden. Durch den vorgeschalteteten Service wird der direkte Zugriff auf den MapServer blockiert und nur angemeldete Nutzer können die OGC-Dienste nutzen.            Ein Beispiel für einen OGC-Zugriff wäre folgende Parametrisierung der URL:  https://monitor.ioer.de/monitor_api  /user?  id=_F13RG&amp;amp; : Indikator ID  key=5HbHOLs7eKQmHJ8r5og2P91qr9tAviBO&amp;amp; : Generierter API-Key des Nutzers, welcher über die Website erstellt wurde  service=wcs : Gibt an, welcher OGC-Service genutzt werden soll (wfs,wcs, wms)Alle URl und Indikatoren lassen sich auch direkt über die Tabellenansicht im Userbereich anzeigen.Im folgenden Diagramm ist die Funktionsweise des Streaming-Dienstes dokumentiert.Im ersten Schritt werden aus der URL die entsprechenden Parameter herausgefiltert. Dann wird geprüft ob der API-Key korrekt ist, indem die in der Datenbank hinterlegten- mit den angefragten Werten verglichen werden. Ist der API-Key fehlerhaft, wird eine entsprechende Fehlermeldung an den Clienten zurück geschickt. Ist der Key korrekt wird die Anfrage an den MapServer für den entsprechenden Service gestellt und der Response an den Clienten gestreamt.route(/login)LoginDiese Methode baut auf die Flask-Bibliothek Flask-Login auf und behandelt das einloggen des Nutzers über das entsprechende Formular. Innerhalb der Methode werden dabei nacheinander folgende Bedingungen überprüft:  Stimmen Username und Passwort überein  Welche Rechte hat der Nutzer → 1 für User und 2 für Admin, welche in der Datenbank unter der Tabelle users in der Spalte _access: abgelegt.route (/signup)RegistrierungDiese Methode hat die Aufgabe die von Nutzer eingetragenen und an den HTTP-Endpoint geschickten Daten in der Datenbank zu speichern. Eine weitere Aufgabe besteht darin zu prüfen, ob der Nutzername oder die Mailadresse bereits in der Datenbank vorhanden ist, in diesem Fall wird eine entsprechende Fehlermeldung an den Clienten zurückgegeben.Stimmen alle Felder überein wird eine neue Instanz der Klasse-User erzeugt und diese in der Datenbank abgelegt. Für das Speichern in der DB wird die Bibliothek  Flask-SQLAlchemy verwendet.Ein Beispiel für das programmatische Anlegen eines neuen Nutzers ist im folgenden Beispiel aufgeführt:new_user = User(username=username, email=email, password=hashed_password, lastname=form.lastname.data,                firstname=form.firstname.data, facility=form.facility.data, access=1,                business=form.business.data, confirmed=False)db.session.add(new_user)Wurde der Nutzer angelegt, wird eine Mail an seine angegebene Adresse geschickt, um den Account zu verifizieren. Diese Aufgabe wird von der Route Mail-Confirm übernommen.Für den Clienten wird das Template signup.html aus dem static-Verzeichnis gerendert, über dieses erfolgt die Eingabe. Fehler werden durch Flask-Markup in das template eingefügt.route (/confirm/token)Diese Route ruft die Methode confirm_email(token_pass) auf, ihr muss der generierte Token übergeben werden. Hierbei wird die Email-Adresse anhand des generierten Tokens überprüft. Der Nutzer bekommt nach seiner Anmeldung eine Mail mit dem Registrierungslink, beim anklicken wird er an diesen Enpoint geleitet.Ist der Token korrekt wird in der Datenbank in der Tabelle users die Spalte confirmed auf True gesetzt. Am Schluss wird der User ausgeloggt, um sich anzumelden.Bei einem Fehler wird die entsprechende Fehlermeldung angezeigt.Für den Clienten wird das Template confirmed_mail.html aus dem static-Verzeichnis gerendert.route (/services)Diese Route hat die Aufgabe aus dem static-Verzeichnis dem Clienten alle Services aufzulisten. Hierfür wird die service.html gerendert. Die Funktion prüft dabei ob der Nutzer angemeldet ist, um auch nur berechtigte Zugriffe zuzulassen. Ist der Nutzer nicht angemeldet, wird die login.html gerendert.route (/reset)Passwort zurücksetzenDiese Route hat die Aufgabe das zurücksetzen des Passwortes zu steuern. Hat der Nutzer seine Emailadresse eingegeben, wird überprüft ob dieses in der Datenbank hinterlegt ist.  Trifft dies zu wird ein Token generiert und mit der Hilfe der Mailer-Klasse das Passwort an die angegebene Mailadresse geschickt. der generierte Token wird dabei mit der Hilfe der Token-Klasse erstellt und wird aus der Mailadresse generiert.route (/reset/token)Diese Route wird aufgerufen, wenn der Nutzer seine Mail zum zurücksetzen des Passwortes bekommen hat und den darin enthaltenen Link klickt.Ein Beispiel Link wäre folgender:https://monitor.ioer.de/monitor_api/reset/ImwubXVjaGFAaW9lci5kZSI.D6xN-w.Ik_GXgQuTDrleuX_Skg_YHr9K5YIm ersten Schritt wird der übergebene Token überprüft, ist er korrekt kann das Passwort geändert werden. Ist der Token nicht korrekt oder ausgelaufen (siehe Token)Durch das gerenderte HTML-Dokument reset_passwort.html aus dem  static bekommt der Nutzer die Möglichkeit ein neues Passwort anzugeben.ModelsMailerDiese Klasse übernimmt im User-Service die Aufgabe alle notwendigen Mails zu verschicken, über die Methode send_mail wird ein neues Mail-Objekt instanziiert, aus der Bibliothek Flask-Mail und an den angegebenen User (to) gesendet. Der Inhalt der Mail ist dabei innerhalb des template fest vorgegeben und befindet sich im static als reset_password_mail.html.UserDiese Klasse erbt von UserMixin und db.Model und ist das Grundgerüst eines neuen/angemeldeten Nutzers. Die Klassen-Variable confirmed gibt hierbei wieder ob dem Nutzer seine Mailadresse bestätigt ist oder nicht. Default ist Sie None. Die Klasse bildet dabei alle Felder der Datenbanktabelle user ab, in welcher alle notwendigen Informationen abgelegt sind.            Methodenname      Parameter      Return      Info                  init      username, password, email,lastname,firstname,facility,access,business,confirmed,confirmed_on=None      Constructor :wink:      Diese Methode erstellt eine neue Instanz der Klasse User, hierbei ist der Parameter confirmed_on als Default None.              is_authenticated             Boolean:state      Methode welche wiedergibt, ob der Nutzer authentifiziert ist, also ob seine Mail korrekt ist              is_active             String:access      gibt wieder, welche rechte der Nutzer besitzt → TODO              is_anonymous             Boolean:state      zeigt an ob der Nutzer einen Anonymen Status besitzt → TODO              get_id             int:id      gibt die Id des Nutzers zurück      TokenDiese Klasse regelt das Verifizieren und erstellen eines Token. Sie wird hierbei bei der Überprüfung der Mailadresse des Nutzers eingesetzt.  Für die Serilizierung wurde die Bibliothek itsdangerous eingesetzt.            Methodenname      Parameter      Return      Info                  generate_confirmation_token()      String:email      String:token      Methode, welche aus der übergebenen Mailadresse einen Token erstellt              confirm_token      String:token, Int:expiration      String:email      Methode welche den Token zu der übergebenen Mail transformiert. Anhand der expiration kann festgelegt werden, wie lange der Token gültig ist. Default ist 3600      SicherheitIn diesem Kapitel wird der Punkt Sicherheit der API-Dokumentiert, hierbei wurde größtenteils auf die On-Board Mittel der Flask-Library zurückgegriffen.URL-ManipulierungUm auch nur berechtigte Nutzer die jeweilige URL zur Verfügung zu stellen, wurde der Dekorator @login_required aus der Bibliothek Flask-Login eingesetzt.Ist der Nutzer nicht angemeldet wird er zurück auf die Anmeldeseite geleitet. Somit ist es nicht möglich unangemeldet auf die OGC-Service Seite zuzugreifen.Anbei die Fallunterscheidung:    if current_user.is_authenticated:        return render_template('user/services.html', key=current_user.api_key, access=current_user.access)    else:       return redirect(&quot;{}login&quot;.format(Config.URL_ENDPOINT))SQL-InjektionSQL-Injection (dt. SQL-Einschleusung) bezeichnet das Ausnutzen einer Sicherheitslücke in Zusammenhang mit SQL-Datenbanken, die durch mangelnde Maskierung oder Überprüfung von Metazeichen in Benutzereingaben entsteht. WikipediaDies kann beispielsweise auftreten wenn Passwort und Username von der Datenbank abgefragt werden und dabei der Template String für den Username so manipuliert wird, das immer True zurückgegeben wird.In der Anwendung wurde die Bibliothek  Flask-SQLAlchemy eingesetzt. Welche die entsprechenden Nutzer herausfiltert.Am Besipiel wurde die Email übergeben und der Nutzer aus der DB authentifiziert.user = User.query.filter_by(email=email).first()",
    "url": "http://localhost:4000/monitor-api-doku/docs/user/backend/backend.html",
    "relUrl": "/docs/user/backend/backend.html"
  },
  "3": {
    "id": "3",
    "title": "Backend",
    "content": "BackendDie Hauptlast bei für die Administrierung der Dienste liegt im Backend. Welche in diesem Kapitel anhand ihrer Klassen und Schichten dokumentiert werden soll.  Services          OGC-Dienste      Indicator-Values      GeoMIS        Interfaces  Models  routesServicesDie Services übernehmen die Instanziierung der Objekte und erstellen die vom Clienten über das Dashboard gewünschten Dienste über die REST-Schnittstelle (routes.py). Für die OGC-Dienste wurde das Factory-Pattern eingesetzt, welches je nach Parametrisierung, den entsprechenden OGC-Layer instanziiert.OGC-FactoryDie OGC-Factory wird von der routes.py aufgerufen um die gewünschten Dienste zu erstellen. Die Factory-Pattern-Methode definiert dabei ein Interface für die Erstellung von Objekten und delegiert die Objekterstellung an die Sub-Klassen. Ziel ist, dass der Client nichts von der Objekt-Instantiierung mitbekommt und über eine gemeinsame Schnittstelle auf die Objekte zugreift. Factory-Patterns kapseln dadurch den Creation Code vom Client [Quelle].Um dies zu verdeutlichen ist nachfolgend der Code abgebildet:class OgcFactory:    def __init__(self,_service):        self.service = _service.lower()        #localhost for testing        if(&quot;localhost&quot; in request.url or &quot;127.0.0.1:5000&quot; in request.url):            app.logger.debug(&quot;OGC Service for localhost&quot;)            #dummy path            self.path ='G:  test  '.format(self.service)        # server path        else:            app.logger.debug(&quot;OGC Service for monitor.ioer.de&quot;)            #dummy path            self.path = '/server/'.format(self.service)    def create_service(self):        if self.service =='wms':            return WmsService(self.path)        elif self.service =='wcs':            return WcsService(self.path)        elif self.service=='wfs':            return WfsService(self.path)Der Konstruktor definiert dabei auf welchen Pfaden die Services erstellt werden sollen.WCS-ServicesWFS-ServiceWMS-ServiceDie Klassen WCS-Services, WFS-Service und WMS-Service implementieren die vom OgcService-Interface definierten Methoden.Hierbei werden in der Methode createAllServices alle für die OGC-Rasterdienste bzw. Vektordienste freigegebenen Indikatoren vom Backend abgefragt. Diese Aufgabe wird von der Klasse Indicator-Values übernommen.Anhand einer Schleife wird für jeden verfügbaren Indikator ein neuer IoerIndicator instanziiert und an die writeFile Methode übergeben. Diese erstellt anhand der Getter-Methoden des übergebenen Indikators das entsprechende Mapfile in dem angegebenen Pfad. Der Pfad wird hierbei im Konstruktor übergegeben, diese Aufgabe übernimmt die Factory.Folgend sind die Parameter und Methoden dokumentiert.            Methode      Parameter      Beschreibung                  public: init      optional-String:Path      Konstruktor :wink:, Der Pfad Paramter wird bei der Verwendung der Factory durch diese übernommen              public: createAllServices      Object: Indikator, optional-String:Path      Methode um einzelne Dienste für einen übergebenen Indikator zu erstellen              private: writeFile      optional-String:Path)      Diese Methode erstellt anhand des übergebenen Indikators das gewünschte Mapfile, primär wird der Pfad aus dem im Konstruktor definierten Pfad übergeben. Als Rückgabe wird ein Objekt mit dem Indikator und dessen Status (erstellt/Fehler) übergeben.      Indicator-ValuesDiese Klasse hat die Aufgabe für die Übergebene Raumgliederung alle verfügbaren Indikatoren vom Monitor-Backend abzurufen. Über die Methode getAllAvaliableServiceValues werden anhand des Paramters Raumgliederung (raster,gebiete) alle verfügbaren Indikatoren abgerufen und ein JSON-Objekt zurückgegeben. Der Code der Klasse ist nachfolgend abgebildet.class IndicatorValues:    def __init__(self,format):        self.url = Config.URL_BACKEND_MONITOR        self.json = '{&quot;format&quot;:{&quot;id&quot;:&quot;%s&quot;},&quot;query&quot;:&quot;getAllIndicators&quot;}' % format        self.format=format        req = requests.post(self.url, data={'values':self.json})        self.values = json.loads(req.text)        print (self.values)    #methon to return all possible indicator values which are possible for an indicator    def getAllAvaliableServiceValues(self,service):        res =[]        for x in self.values:            cat_name = self.values[x]['cat_name']            cat_name_en = self.values[x]['cat_name_en']            values = self.values[x]['indicators']            ind_values = []            for i in values:                # if 1: the service is avaliable else not                if int(values[i][&quot;ogc&quot;][service]) == 1:                    ind_val=dict(values[i])                    ind_id = dict({&quot;id&quot;:i})                    merge = dict()                    merge.update(ind_id)                    merge.update(ind_val)                    del merge['atkis']                    del merge['ogc']                    ind_values.append(merge)            res.append({'cat_id':x,'cat_name':cat_name,'cat_name_en':cat_name_en,&quot;values&quot;:ind_values})        return resGeoSNDiese Klasse implementiert das Interface GeoSN-Service und hat die Aufgabe, die Dienste des IÖR-Monitors mit dem GeoMIS zu verknüpfen. Der Service wurde notwendig, da zum aktuellen Zeitpunkt keine API auf der Seite des GeoMIS vorhanden ist, welche diese Aufgabe übernimmt.Anhand der vom GeoMIS :email: bereitgestellten XML-Dateien, werde diese mit den aktuellen Informationen der Datenbank synchronisiert. Hierfür parst die Methode updateFile alle XML-Dateien in dem vorgegebenen Verzeichnis. Passt die Parametrisierung mit der gesetzten Klassenvariable Indikator überein, wird dieses aktualisiert. Hierfür  fällt der händische Update-Vorgang in der GUI des GeoMIS weg. Durch die Freigabe des Verzeichnisses nach außen, kann das GeoMIS die in den XML-Dateien definierten Dienste harvesten.Die Methode update ruft von Dienst Indicator-Values alle Raster und Vektor Indikatoren auf, welche das IÖR nach außen freigibt und ruft auf deren Basis die private Methode updateFile auf. Iterativ wird dabei die Klassenvariable Indikator gesetzt, welche jeweils das Model IÖR-Indikator ist.InterfacesEine Schnittstelle (englisch interface) gibt in der objektorientierten Programmierung an, welche Methoden in den unterschiedlichen Klassen vorhanden sind oder vorhanden sein müssen. QuelleOgcServiceDieses Interface definiert die notwendigen Methoden für die Erstellung eines IÖR-OGC Dienstes.GeoSN-ServiceDieses Interface definiert die notwendigen Methoden für die Erstellung eines GeoSN Dienstes.IndikatorDieses Interface definiert einen Indikator für das IÖR-Indikatorensystem.ModelsRepräsentiert den internen Zustand eines Objekts und speichert alle interessanten Geschäftsdaten. Ein Model bietet Methoden an, mit denen sich der aktuelle Zustand erfragen und ändern lässt. QuelleIÖR-IndikatorDiese Klasse wird verwendet um innerhalb der Sevices einen Indikator zu instanziieren und damit auf die getter zuzugreifen. Das Verhalten der Klasse wird dabei durch das Interaface Indikator definiert.Die Klasse besitzt auch eine Methode toJSON, welche verwendet wird um in den Service-Klassen den Status der Indikatorerstellung festzuhalten. Hierfür wird ein sogenannter state übergeben. Nachfolgend ist der Code abgebildet:def toJSON(self,state=&quot;create&quot;):    return {self.id:{            &quot;state&quot;: state,            &quot;name&quot;: self.name,            &quot;description&quot;: self.description,            &quot;times&quot;: self.time_string,            &quot;spatial_extends&quot;: self.spatial_extends,            &quot;unit&quot;: self.units,            &quot;methodik&quot;: self.methodology        }}ToolboxDie Toolbox übernimmt Aufgaben die in vielen Klassen benötigt werden. Nachfolgend ist ihr Code abgebildet.class Toolbox:    def clean_string(self, string):        d = {&quot;  &quot;: &quot;&quot;, &quot; n&quot;: &quot;&quot;,'&quot;':&quot;&quot;,&quot;Kurzbeschreibung&quot;:&quot;&quot;,&quot;  &quot;:&quot;&quot;}        for i, j in d.items():            string = string.replace(i, j)        return string.strip()    def json_validator(self,data):        try:            json.loads(data)            return True        except ValueError as error:            return False            Methode      Definition                  clean_string      Anhand eines übergebenen Strings wewrden nicht benötigte Charaktere aus diesem entfernt, dies kommt vor allem bei den langen Definitionen vor, welche von den Mapfiles nicht gelesen werden können              json_validator      Prüft ob der übergebene String im JSON-Format ist, sonst wird False zurückgebenen.      ColorDie Klasse Color wird für den WMS-Service verwendet, um die Farbliche Klasseneinteilung der Mapfiles zu bewerkstelligen und um notwendige Umrechnungen durchzuführen.            Methode      Paramter      Rückgabe      Definition                  __init__      String:min_color,String:max_color,int:classes      Konstruktor :wink:      Bei der instanziierung der Color-Klasse muss der Minimale- und MAximale Farbwert als HEX-Code angegeben werden. Desweiteren ist es wichtig die Anzahl der Klassen zu definieren, um den Aufbauenden Berechnungen mitzuteilen, welche Breite des farbliche Spektrum besitzen soll.              private:Berechnung      String:Min-Color, String:Max-Color      Array      Diese Methode erstellt ausgehend von der Anzhal der Klassen ein Array, welches für die übergebenen Minimal- und Maximalwerte die dazwischenliegenden Farbcodes generiert.              private:HexToRGB      String:Hex-Code      String:RGB-Code      Diese Methode berechnet für den übergebenen Hex-Code den RGB-Wert aus              private:RGBToHex      String:RGB-Code      String:Hex-Code      Diese Methode berechnet für den übergebenen RGB-Code den HEX-Wert aus              public:buildColorPalette             Array      Diese Methode nutzt die privaten Methoden um die Finale Farbpallete zu erstellen. In dem Array wird dann für jede Klasse der entsprechende Farbwert als HEX-Code gespeichert              public: toString             String      Gibt die Klassen-Paramter als String zurück      RoutingDas Route Mapping wurde für die administrativen Aufgaben implementiert. Um die Übersicht zu bewahren wurde wie auch schon für die anderen Aufgabend er API ein Blueprint angelegt, mit dem Kürzel admin, welches die URL erweitert. Nachfolgend ist der Code abgebildet, welcher demonstriert welche Klassen bei der jeweiligen URL aufgerufen werden.Die Schnittstelle ist nur für angemeldete User zu erreichen, was über die Expession @login_required realisiert wurde.@admin.route('/')@login_requireddef admin_page():    return render_template(&quot;admin/index.html&quot;)@admin.route('/wfs',methods=['GET', 'POST'])@login_requireddef wfs_service():    wfs = OgcFactory('wfs')    return jsonify(wfs.create_service().createAllServices())@admin.route('/wcs',methods=['POST'])@login_requireddef wcs_service():    wcs = OgcFactory(&quot;wcs&quot;)    return jsonify(wcs.create_service().createAllServices())@admin.route('/wms',methods=['POST'])@login_requireddef wms_service():    wms = OgcFactory(&quot;wms&quot;)    return jsonify(wms.create_service().createAllServices())@admin.route('/geosn',methods=['POST'])@login_requireddef geosn_service():    geosn = GeoSN('/srv/www/htdocs/monitor_ogc_xml/')    return jsonify(geosn.update())In der nachfolgenden Tabelle sind die URL-Endpoints und deren Aufgaben kurz zusammengefasst.            Endpoint      Beschreibung                  /admin/      beim Aufruf dieser URL wird das zugrundeliegende Template aus dem Static gerendert (admin/index.html).              /admin/wfs      Hier wird der OGC-Factory als Service wfs mitgegeben, wodruch alle Web Feature Services des IÖR aktualisiert werden.              /admin/wcs      Hier wird der OGC-Factory als Service wcs mitgegeben, wodruch alle Web Coverage Services des IÖR aktualisiert werden.              /admin/wms      Hier wird der OGC-Factory als Service wms mitgegeben, wodruch alle Web Map Services des IÖR aktualisiert werden.              /admin/geosn      Hier wird die Klasse GeoSN aufgerufen, womit alle Dienste des IÖR im GeoMIS aktualisiert werden.      ",
    "url": "http://localhost:4000/monitor-api-doku/docs/admin/backend/backend.html",
    "relUrl": "/docs/admin/backend/backend.html"
  },
  "4": {
    "id": "4",
    "title": "Datenbank",
    "content": "DatenbankDas Backend verwendet für die Nutzerverwaltung die Postgre Datenbank, welche auf dem Server installiert ist. Sie hat den Namen monitor_ogc.Nachfolgend sind die Tabellen abgebildet, deren Persistenz über den User_Loader sichergestellt ist und damit den Nutzer abbildet.Die Datenbank verwendet zum aktuellen Zeitpunk nur die Tabelle user, deren Struktur folgende abgebildet ist. Das Passwort ist verschlüsselt abgelegt und kann nicht eingesehen werden.            #      Name      Typ      Länge      Null      Voreinstellung      Info                  1      email      varchar             Y             Mail des Nutzers              2      username             varchar      Y             Nutzername              3      password      varchar             Y             verschlüsselt abgelegtes Passwort              4      lastname      varchar             Y             Familienname              5      firstname      varchar             Y             Name              6      facility      varchar             Y             Einrichtung              8      api_key      varchar             Y             generierter API-Key für doe OGC-Dienste              9      id      int4      4      N      nextval(‘users_id_seq’::regclass)                     10      access      int4      4      Y      1      1 für Nutzer und 2 für Admin              11      business      varchar             Y             Geschäftsfeld              12      confirmed      bool      1      Y             ist die Mail bestätigt ? Ja/Nein              13      confirmed_on      date      4      Y             an welchem DAtum wurde die Mail bestätigt      ",
    "url": "http://localhost:4000/monitor-api-doku/docs/user/database/database.html",
    "relUrl": "/docs/user/database/database.html"
  },
  "5": {
    "id": "5",
    "title": "Frontend",
    "content": "KomponentenRegistrierung und AnmeldungDie Gestaltung der Graphischen Benutzeroberfläche wurde mit Bootstrap realisiert.Hiermit konnte das Styling der GUI-Elemente an die Bibliothek abgegeben werden, welche auch den Responsive Part übernimmt.Diese Technologie wurde auch in der Anmeldung eingesetzt.Innhalb dieser Komponenten wurden nur die Standard HTML-Methoden innerhalb des jeweiligen Formulars eingesetzt.Login RegistrierungNutzerbereichApiKey.jsxUm einen Key zu Generieren muss der Nutzer den entsprechenden Button klicken. Dieser wird vom Flask Backend generiert. Die Kommunikation erfolgt dabei über HTTPS-GET mit der Unterstützung von JQuery-Ajax. Der Generierungsvorgang wird im Abschnitt Backend dokumentiert.Die Klasse ApiKey erbt dabei von React.Component.In der folgenden Tabelle ist die Klasse ApiKey dokumentiert:            Methode      Values      Return      Info                  constructur      props      Constructor :wink:      werden erstmal keine Variablen gesetzte sondern nur default (state,ref,methoden werden an das DOM gebunden)              copyToClipboard                    Methode um den generierten ApiKey zu Kopieren, womit der Nutzer den Schlüssel beliebig einfügen kann              static makekey             String:key      Methode welche einen Schlüssel generiert und zurückgibt              insert      String: (key,username,user_id)             Methode welche anhand der übergebenen Parameter den Generierten Parameter an das Backend übergibt, welches den Schlüssel für den Nutzer in der PostgreSQL speichert.              render             JSX      rendert die Komponente im ReactDOM      Menü.jsxAuswahlmenü für den Nutzer, in welchem er zwischen den Seiten hin- und herschalten kann.Die Klasse an sich hat nur die Aufgabe das Menü zu rendern und damit wiederverwendbar zu machen.service.jsInnerhalb der Datei wird die Tabelle, welche dem Nutzer alle zur Verfügung gestellten OGC-Services zeigt, generiert und die notwendigen Events im DOM registriert.Durch die Verwendung der JQuery Bibliothek DataTables wird hier nicht React eingesetzt sondern JavaScript-Objekte. Diese werden folgend dokumentiert.  const table            Methode      Values      Return      Info                  getTableObject                    Gibt das JQuery-DOM Objekt der Tabelle zurück              init      Array: options             Erstellt die Tabelle anhand der gesetzten Paramter. Hierbei kann [“raster”,”wcs”],[“raster”,”wms”],[“gebiete”,”wfs”] gesetzt werden. Je nach getztem Array wird die Tabelle mit den entsprechenden Indikatoren generiert. Dabei werden die notwendigen Informationen über die Funktion getData geholt und innerhalb der Tabelle generiert. Das generierte HTML wird dabei als Template String dem DOM hinzugefügt.              getData      String:setting      Object:Response      Über HTTP-POST via JQuery-Ajax werden alle notwendigen Indikator-Informationen vom Backend des Monitors (Doku) abgefragt. Das Ergebnis wird als Return zurückgegeben.              destroy                    entfernt das DataTable PlugIn, von der Tabelle.      Innerhalb des Table-Objektes ist noch das Button-Objekt integriert. Die Buttons haben folgende Aufgaben:  GetCapabilities: zeigt dem Nutzer das Capabilities Dokument (XML) zurück, das alle Informationen enthält, die ein OGC Client benötigt, um Kartenanfragen an den Server zu beantworten  URL Kopieren: kopiert die URL des Services in das Clipboard des Clienten  Karte: öffnet den Indikator im IÖR-Monitor            Methode      Values      Return      Info                  init                    bindet die Button events an das DOM              copyURL      String:url             kopiert die Service URL in das Clint-Clipboard        const chechboxDiese Objekt hat die Aufgabe das Hin- und Herschalten zwischen den OGC-Services zu koordinieren.            Methode      Values      Return      Info                  getContainerObject                    Gibt das JQuery-DOM Objekt des Checkbox-Containers zurück              init                    bindet das change-Event an das DOM, welches je nach Auswahl das table.init(“wfs”/”wcs”) aufruft      ",
    "url": "http://localhost:4000/monitor-api-doku/docs/user/frontend/frontend.html",
    "relUrl": "/docs/user/frontend/frontend.html"
  },
  "6": {
    "id": "6",
    "title": "Frontend",
    "content": "FrontendDas Frontend wurde mit der JavaScript-Bibliothek React verwirklicht. Es besteht hauptsächlich aus 3 Modulen, welche in diesem Kapitel vorgestellt werden. Zur Kommunikation mit dem Backend wurde ein Request Manager implementiert, welcher Axios einsetzt.Alle vorgestellten Klassen erben von der Abstrakten Klasse React.Component, bis auf den Request Manager.ScreenshotInhalt  Seiten-Menü  OGC-Dienste          Update der Dienste        Navigations-Menü  Request Manager  ModalDialogReact-ModuleSeitenmenüDas Seitenmenü hat die Hauptaufgabe die Funktionalitäten zum hin- und herschalten zwischen den einzelnen Funktionen zu ermöglichen und bei einem OnClick-Event ein neues Modul OGC zu erstellen. Hierfür wird in dem Data-Parameter der entsprechende Schlüssel abgefragt und übergeben.In der nachfolgenden Tabelle sind die Parameter für die Erstellung aufgelistet:            id      Funktion                  wms      Web Map Service Modul              wfs      Web Feature Sservice Modul              wcs      Web Coverage Service Modul              geosn      GeoMIS Modul      Das Schlüsselwort wird als React-Property an das OGC-Modul übergeben.const ogc =  &amp;lt; OGC service={service}/&amp;gt;;            ReactDOM.render(            ogc,            document.getElementById('page_content'));OGC-DiensteÜber dieses Modul können die einzelnen Funktionalitäten ausgewählt werden, mit welchen der jeweils gewählte Service manipuliert werden kann. Im Moment sind alle dafür notwendige Funktionen:  Update der Dienste  Neuen Dienst erstellen  Dienst löschen  Übersichtvorhanden, jedoch ist nur der Upate der Dienste implementiert, die anderen Funktionen dienen als Platzhalter.Update der DiensteDie Funktion hat die Aufgabe über den Request-Manager den Update Prozess auf dem Backend anzustoßen. War dies erfolgreich gibt das Backend die Ergebnis-JSON zurück. Diese wird zum besseren Verständnis mit dem Modal-Dialog als Bootstrap-Card View dargestellt. Aus der JSON-Datei können dabei die Informationen entnommen werden, welche verwendet werden um den Status der Erstellung zu visualisieren. In der folgenden Abbildung ist ein Dialogfenster für den GeoDN Service abgebildet und zeigt dabei auch eine fehlgeschlagene Erstellung eines Diesntes, welcher rot hinterlegt wurde.Request ManagerDiese Klasse übernimmt die Kommunikation mit dem Backend und weißt dieses an, die Aktualisierung der Dienste anzustoßen. Dafür wurde die Methode updateOGCService() implementiert, welcher als Parameter der zu erstellende Dienst (wms,wcs,wfs,geosn) übergeben wird. Als Ajax-Bibliothek wurde Axios eingesetzt. Nachfolgend ist der Code abgebildet.class RequestManager{    static updateOGCService(_service){        console.info(&quot;create services for: &quot;,_service);        return axios.post('https://monitor.ioer.de/monitor_api/admin/'+_service);    }}Modal DialogDiese Klasse blendet einen sogenannten Dialog ein, dessen Style von Bootstrap Modal definiert wird. Über den Konstruktor wird dieser React-Komponente das HTML übergeben, welches innerhalb des Dialoges dargestellt (gerendert) werden soll.",
    "url": "http://localhost:4000/monitor-api-doku/docs/admin/frontend/frontend.html",
    "relUrl": "/docs/admin/frontend/frontend.html"
  },
  "7": {
    "id": "7",
    "title": "Home",
    "content": "Dokumenation der Monitor APIDieses Backend wurde mit dem Web-Framework Flask serverseitig umgesetzt, auf der Clienten-Seite kommt React zum Einsatz. Die Kommunikation via HTTPS erfolgt mit den Bibliotheken JQuery und Axios.Die einzelnen Module sind über sogenannte Blueprints voneinander getrennt.In der folgenden Tabelle sind diese zusammengefasst:            Name      Route      Zweck                  Admin      /admin      Verwaltung des Monitors und der OGC-Services, nur für angemeldete Nutzer              User      /user      Nutzerverwaltung für die Anmeldung an der API      Die anderen Module haben folgende Aufgaben:            Name      Zweck                  static      Implementierung auf der Clientenseite              templates      html Dateien für die jeweilige Seite + Email Vorlagen      Das Deployment mit allen notwendigen Tools und Server-Pfaden ist in folgenden PDF.",
    "url": "http://localhost:4000/monitor-api-doku/",
    "relUrl": "/"
  },
  "8": {
    "id": "8",
    "title": "Sora",
    "content": "SoRa - Sozial-Raumwissenschaftliche ForschungsdateninfrastrukturDa es sich bei Sora um ein reines Backend handelt, wird auch nur dieses vorgestellt. Das Backend hat vor allem die Aufgabe die im SoRa Projekt gestellten Anforderungen zu erfüllen indem freie Nutzeranfragen auf topografischen Geobasisdaten beantwortet werden. Diese werden vom Clienten gestellt.Inhalt  Rest-API          Abfrage von Indikatorwerten zu Koordinaten      Routing zum nächstgelegenen POI      Routing zwischen zwei Koordinaten        RDF          Indicators      Category        Flask (monitor.ioer.de)  Esri-Server (edn.ioer.de)          Abfrage von Indikatorwerten zu Koordinaten      Routing zwischen zwei Koordinaten      Routing zum nächstgelegenen POI        ProblemeArchitekturAlle Anfragen für das SoRa-Forschungsprojekt werden an die Monitor-API geschickt, wofür der Blueprints sora implementiert wurde. Innerhalb der routes.py befindet sich das RequestMapping, welches für die entsprechenden query strings alle Anfragen beantwortet.Auf dem ESRI-Server wurden die Service-Layer implementiert. Der Flask Microservice auf https://monitor.ioer.de/monitor_api/sora nimmt die Requests des Gesis- Location Mapping an. Über die Klasse Request-Manager, werden die Anfragen gestellt. Das die Kommunikation mit einem WPS teilweise sehr kompliziert sein kann, wurde diese Service-Schicht implementiert.REST-SchnittstelleREST steht für REpresentational State Transfer, API für Application Programming Interface. Gemeint ist damit ein Programmierschnittstelle, die sich an den Paradigmen und Verhalten des World Wide Web (WWW) orientiert und einen Ansatz für die Kommunikation zwischen Client und Server in Netzwerken beschreibt. QuelleDiese Schnittstelle wurde sowohl auf dem Esri-Server als auch auf dem Flask-Microservice eingesetzt. Da bei allen durch das Projekt genutzten Diensten z.T. sehr große Koordinaten-Anfragen gestellt werden, unterstützt die API nur POST-Requests. Da auf orginären Rasterkarten gerechnet wird, kann die Anfrage je nach Menge der Koordinaten länger Dauern, wird Polling angewendet. Hierfür wird dem Clienten auf seine POST Anfrage eine JobID übermittelt. Jetzt kann über eine entsprechend parametrisierte GET Anfrage periodisch angefragt werden, ob das Ergebnis bereitgestellt wurde.Nachfolgend ist die Kommunikation mit der REST-API dokumentiert, um Requests und Responses zu verdeutlichen wurden Beispiele hinterlegt. Der Genau Code für die WPS ist im Punkt Esri-Server dokumentiert. Die Code-Beschreibung für Flask ist hier zu finden.  Abfrage von Indikatorwerten zu Koordinaten  Routing zum nächstgelegenen POI  Routing zwischen zwei Koordinaten1. Abfrage von Indikatorwerten zu KoordinatenBeschreibungMit diesem Service können für vorgegebene Koordinaten die jeweiligen Indikatorwerte abgefragt werden. Wird ein Buffer-Wert gesetzt, ermittelt der Service den Durchschnitt des Indikators innhalb des Buffer-Bereichs. Hierbei wird ein quadratische Buffer um jede Koordinate gesetzt, dessen Räumlicher Durchschnitt über den Paramter buffer gesetzt werden kannEndpoint: https://monitor.ioer.de/monitor_api/sora/services  Post der JSON-Datei:          Query String: job=coordinates              Datei: folgend eine beispielhafte JSON Datei, welche alle notwendigen Parameter übermittelt          {      &quot;coordinates&quot;:          [{&quot;id&quot;:8291,&quot;x&quot;:&quot;4340896,28050814&quot;,&quot;y&quot;:&quot;2764378,83432727&quot;},          {&quot;id&quot;:3058,&quot;x&quot;:&quot;4340657,55155301&quot;,&quot;y&quot;:&quot;2765292,51267246&quot;},          {&quot;id&quot;:3438,&quot;x&quot;:&quot;4342453,82536125&quot;,&quot;y&quot;:&quot;2764230,5410444&quot;},          {&quot;id&quot;:249,&quot;x&quot;:&quot;4339813,12908578&quot;,&quot;y&quot;:&quot;2765946,78532257&quot;},          {&quot;id&quot;:3800,&quot;x&quot;:&quot;4339879,51749317&quot;,&quot;y&quot;:&quot;2765648,13305142&quot;}],      &quot;indicators&quot;:          [{&quot;id&quot;:&quot;S12RG&quot;,&quot;year&quot;:&quot;2012&quot;},          {&quot;id&quot;:&quot;S12RG&quot;,&quot;year&quot;:&quot;2015&quot;},          {&quot;id&quot;:&quot;F01RG&quot;,&quot;year&quot;:&quot;2015&quot;,&quot;buffer&quot;:&quot;100&quot;}],      &quot;epsg&quot;:&quot;3035&quot;  }                                      coordinates: x/y Koordinaten mit der gesetzten id, hierbei ist es egal ob die Koordinaten als Zahlenwert(.) oder String übergeben werden. Es würde genauso funktionieren:              ...  {&quot;id&quot;:8291,&quot;x&quot;:&quot;4340896.28050814&quot;,&quot;y&quot;:&quot;2764378.83432727&quot;}  ...                                indicators: id des Indikators und der gewünschte Zeitschnitt, optional ist der buffer, welcher in Meter angegeben wird.          epsg: zugrundeliegendes Koordinatensystem          Als Antwort auf den request erfolgt eine JSON, welche die JobID beinhaltet und den Status.                  {   &quot;jobId&quot;: &quot;j14585674d2434aada462cffe22862324&quot;,   &quot;jobStatus&quot;: &quot;esriJobSubmitted&quot;  }                Beispiel mit curl:          curl --header &quot;Content-Type: application/json&quot;         --request POST         --data '{&quot;coordinates&quot;:[{&quot;x&quot;:&quot;12.067024122630599&quot;,&quot;y&quot;:&quot;54.1015602797111&quot;,&quot;id&quot;:66},{&quot;x&quot;:&quot;12.141539756251&quot;,&quot;y&quot;:&quot;54.1154796784391&quot;,&quot;id&quot;:99}],&quot;indicators&quot;:[{&quot;id&quot;:&quot;S12RG&quot;,&quot;year&quot;:&quot;2017&quot;}],&quot;epsg&quot;:&quot;4326&quot;}'         https://monitor.ioer.de/monitor_api/sora/services?job=coordinates        Als Ergebnis wird dann folgende JSON mit einer Job-ID geliefert:          {  &quot;jobId&quot;: &quot;j19e57f40c4a44755a32078d9ad7097f2&quot;,  &quot;jobStatus&quot;: &quot;esriJobSubmitted&quot;  }                    Wurde dem Clienten die JobID als Response übermittelt, kann via HTTP-GET das Ergebnis periodisch angefragt werden. Hat das Backend ein Ergebnis zur Verfügung, wird dieses bereitgestellt.  GET des Ergebnisses:          Query Strings:                  job=coordinates          job_id=id des Jobs aus dem Post-Request, in diesem Beispiel j14585674d2434aada462cffe22862324                    Wird der Job noch berechnet, sendet der Service eine entsprechende Mitteilung als JSON zurück und muss weiter angefragt werden. Liegt das Ergebnis vor, wird das Ergebnis als JSON gesendet.        Beispiel mit curl:     curl --request GET        -d 'job=coordinates'      -d 'job_id=j19e57f40c4a44755a32078d9ad7097f2'      https://monitor.ioer.de/monitor_api/sora/services    rechnet der Service noch wird z.B. folgende JSON als Response geliefert:     {     &quot;jobId&quot;: &quot;jc7e4847561014440a06cd6e4cf2e7fb2&quot;,     &quot;jobStatus&quot;: &quot;esriJobExecuting&quot;,     &quot;messages&quot;: [     {     &quot;type&quot;: &quot;esriJobMessageTypeInformative&quot;,     &quot;description&quot;: &quot;Submitted.&quot;     },     {     &quot;type&quot;: &quot;esriJobMessageTypeInformative&quot;,     &quot;description&quot;: &quot;Executing...&quot;     }     ] }        ist der Service fertig wird z.B. folgender Response geliefert:         { &quot;paramName&quot;: &quot;outputJSON&quot;, &quot;dataType&quot;: &quot;GPString&quot;, &quot;value&quot;: [ { &quot;y&quot;:  &quot;54.1015602797111&quot;,     &quot;x&quot;:  &quot;12.067024122630599&quot;,     &quot;values&quot;:  [     {     &quot;indicator&quot;:  &quot;S12RG&quot;,     &quot;indicator_value&quot;:  &quot;100.0&quot;,     &quot;time&quot;:  &quot;2017&quot;     } ],     &quot;id&quot;:  &quot;66&quot; }, { &quot;y&quot;:  &quot;54.1154796784391&quot;,     &quot;x&quot;:  &quot;12.141539756251&quot;,     &quot;values&quot;:  [     {     &quot;indicator&quot;:  &quot;S12RG&quot;,     &quot;indicator_value&quot;:  &quot;100.0&quot;,     &quot;time&quot;:  &quot;2017&quot;     } ],     &quot;id&quot;:  &quot;99&quot; } ] }          Die folgenden Dienste berechnen mit Hilfe des Open Route Service, die Wegstrecken zwischen den übergebenen Koordinaten und der Anforderung. Hierbei ist es möglich durch die Variierung der Parameter, die Berechnung zu beeinflussen.2. Routing zum nächstgelegenen POIBeschreibungDieser Service berechnet auf der Grundlage des übergebenen Punktes, die Distanz zum nächst gelegenen POI.Endpoint: https://monitor.ioer.de/monitor_api/sora/services  Post der JSON-Datei:          Query String: job=routing_poi      Datei: folgend eine beispielhafte JSON Datei, welche alle notwendigen Parameter übermittelt         {&quot;coordinates&quot;:     [{&quot;id&quot;:5297,&quot;x&quot;:&quot;4339535,6687453&quot;,&quot;y&quot;:&quot;2765964,35707297&quot;},     {&quot;id&quot;:4453,&quot;x&quot;:&quot;4339873,89116431&quot;,&quot;y&quot;:&quot;2764805,05240828&quot;},     {&quot;id&quot;:4989,&quot;x&quot;:&quot;4339655,35336738&quot;,&quot;y&quot;:&quot;2765570,54764701&quot;},     {&quot;id&quot;:7789,&quot;x&quot;:&quot;4339816,61177691&quot;,&quot;y&quot;:&quot;2764105,56506073&quot;}     ......     ], &quot;options&quot;:[{&quot;profile&quot;:&quot;walking&quot;,&quot;epsg&quot;:{&quot;input&quot;:&quot;3035&quot;,&quot;output&quot;:&quot;25833&quot;}} ]}              Optionen innerhalb der JSON:                  options:                          profile: gibt an, wie der gefundene POI erreicht werden soll. Unterstützt werden im Moment: walking, driving              epsg: gibt an, in welchem Koordinatensystem die Punkte sich befinden und können optional auch in eine anderes Koordinatensystem transformiert werden. Hierfür muss der optionale Parameter output angegeben werden.              poi: gibt an, welcher nächst gelegene POI berechnet werden soll. Aktuell werden Grünflächen als green_areas und der Öffentliche Nahverkehr als public_transport.                                            Beispiel mit curl:     curl --header &quot;Content-Type: application/json&quot;           --request POST           --data '{&quot;coordinates&quot;:[{&quot;id&quot;:5297,&quot;x&quot;:&quot;4339535,6687453&quot;,&quot;y&quot;:&quot;2765964,35707297&quot;}],&quot;options&quot;:[{&quot;profile&quot;:&quot;walking&quot;,&quot;epsg&quot;:{&quot;input&quot;:&quot;3035&quot;},&quot;poi&quot;:&quot;public_transport&quot;}]}'           https://monitor.ioer.de/monitor_api/sora/services?job=routing_poi    Als Ergebnis wird dann folgende JSON mit einer Job-ID geliefert:     { &quot;jobId&quot;: &quot;j19e57f40c4a44755a32078d9ad7097f2&quot;, &quot;jobStatus&quot;: &quot;esriJobSubmitted&quot; }        GET des Ergebnisses:          Wie im Service coodinates, nur jetzt als job routing_poi angegeben        Beispiel mit curl:     curl --request GET       -d 'job=routing_poi'     -d 'job_id=j19e57f40c4a44755a32078d9ad7097f2'     https://monitor.ioer.de/monitor_api/sora/services    rechnet der Service noch wird z.B. folgende JSON als Response geliefert:     {     &quot;jobId&quot;: &quot;jc7e4847561014440a06cd6e4cf2e7fb2&quot;,     &quot;jobStatus&quot;: &quot;esriJobExecuting&quot;,     &quot;messages&quot;: [     {     &quot;type&quot;: &quot;esriJobMessageTypeInformative&quot;,     &quot;description&quot;: &quot;Submitted.&quot;     },     {     &quot;type&quot;: &quot;esriJobMessageTypeInformative&quot;,     &quot;description&quot;: &quot;Executing...&quot;     }     ] }        ist der Service fertig wird z.B. folgender Response geliefert:     {     &quot;paramName&quot;: &quot;outputJSON&quot;,     &quot;dataType&quot;: &quot;GPString&quot;,     &quot;value&quot;: [         {             &quot;x&quot;: &quot;4339535,6687453&quot;,             &quot;y&quot;: &quot;2765964,35707297&quot;,             &quot;id&quot;: &quot;5297&quot;,             &quot;values&quot;: [                 {                     &quot;endpoint&quot;: {                         &quot;x&quot;: &quot;4339346.90443&quot;,                         &quot;y&quot;: &quot;2766960.30919&quot;                     },                     &quot;distance_open_route&quot;: {                         &quot;value&quot;: &quot;1559.4&quot;,                         &quot;unit&quot;: &quot;m&quot;                     },                     &quot;duration_open_route&quot;: {                         &quot;value&quot;: &quot;1122.8&quot;,                         &quot;unit&quot;: &quot;s&quot;                     }                 }             ]         }     ] }      Die Ergebnis-JSON beinhaltet die Koordinaten der nächstgelegenen Grünfläche und die Distanz zu dieser in Meter. Auf der Grundlage des definierten Profiles wird auch die benötigte Zeit angegeben.3. Routing zwischen zwei KoordinatenBeschreibungÄhnlich des Services Suche nach den räumlich nächst gelegenen POI berechnet dieser Service die Route und die Distanz zwischen zwei Punkten. Hier werden jedoch der Anfangs- und der Endpunkt übergeben, wodurch die Suche nach dem nächst gelegenen POI entfällt.Endpoint: https://monitor.ioer.de/monitor_api/sora/services  Post der JSON-Datei:          Query String: job=routing_xy      Datei: folgend eine beispielhafte JSON Datei, welche alle notwendigen Parameter übermittelt             {&quot;coordinates&quot;:         [{&quot;id&quot;:5297,             &quot;startpoint&quot;:                  {&quot;x&quot;:&quot;4583809.29&quot;,&quot;y&quot;:&quot;3108954.51&quot;},&quot;endpoint&quot;:{&quot;x&quot;:&quot;4584822.66&quot;,&quot;y&quot;:&quot;3109658.40&quot;}         },         {&quot;id&quot;:5298,             &quot;startpoint&quot;:                 {&quot;x&quot;:&quot;4580902.38&quot;,&quot;y&quot;:&quot;3110862.75&quot;},&quot;endpoint&quot;:{&quot;x&quot;:&quot;4583809.29&quot;,&quot;y&quot;:&quot;3108954.51&quot;}         }],     &quot;options&quot;:[{&quot;profile&quot;:&quot;walking&quot;,&quot;epsg&quot;:{&quot;input&quot;:&quot;3035&quot;,&quot;output&quot;:&quot;25833&quot;}}]}              Die Optionen innerhalb der JSON sind gleich des Servies routing_poi        GET des Ergebnisses:          Wie im Service coodinates, nur jetzt als job routing_xy angegeben      RDFDas Resource Description Framework (RDF, engl. sinngemäß „System zur Beschreibung von Ressourcen“) bezeichnet eine technische Herangehensweise im Internet zur Formulierung logischer Aussagen über beliebige Dinge (Ressourcen). Ursprünglich wurde RDF vom World Wide Web Consortium (W3C) als Standard zur Beschreibung von Metadaten konzipiert. Mittlerweile gilt RDF als ein grundlegender Baustein des Semantischen Webs. RDF ähnelt den klassischen Methoden zur Modellierung von Konzepten wie UML-Klassendiagramme und Entity-Relationship-Modell. Im RDF-Modell besteht jede Aussage aus den drei Einheiten Subjekt, Prädikat und Objekt, wobei eine Ressource als Subjekt mit einer anderen Ressource oder einem Wert (Literal) als Objekt näher beschrieben wird. QuelleMit der Beschreibung der Indikatoren und deren Kategorien in RDF, wurde der Beschluss innerhlab der SoRa Projektmitglieder umgesetzt, eine Beschreibung der Metadaten in RDF durchzuführen. Zur Arbeit mit diesem Format wurde die Python-Bibliothek rdflib eingesetzt.IndikatorRDF-AbfrageCodeDiese Klasse fragt bei der Instaziierung vom Monitor-Backend alle verfügbaren Indikatoren ab, welche im Raster-Format vorliegen. Iterativ werden diese Indikatoren und deren Metadaten dem Graphen hinzugefügt.CategoryRDF-AbfrageCodeÄhnlich wie die Indikatoren fragt diese Klasse bei der Instaziierung vom Monitor-Backend alle verfügbaren Kategorien ab, welche für das Raster-Format vorliegen. Iterativ werden diese Kategorien und deren Metadaten dem Graphen hinzugefügt.FlaskGithubDieser Microservice wird für die Kommunikation zwischen Clienten und den WPS eingesetzt, um die Anfragen so leicht wie möglich zu gestalten. Eine Dokumentation zu Flask ist unter dem folgenden Link zu finden.Das nochfolgende UML bildet die verwnedeten Klassen ab, welche nachfolgend genauer Dokumentiert werden.routes.pyHier erfolgt des Request-Mapping, indem genau defineirt wird, was bei welchen query passiert. Im nachfolgenden Code-Block ist der Quellcode abgebildet.#RDF-Schnittstelle um sich die Indikatoren als .ttl auszugeben@sora.route(&quot;/indicator&quot;, methods=['GET', 'POST'])def get_indicators():    indicator = Indicator(json_url=url)    try:        res = indicator.g    except Exception as e:        return abort(500)    if len(res) == 0:        return abort(404)    else:        return Response(res.serialize(format=&quot;turtle&quot;), mimetype=&quot;text/n3&quot;)#RDF-Schnittstelle um sich die Kategorien als .ttl auszugeben@sora.route(&quot;/category&quot;, methods=['GET', 'POST'])def get_categories():    category = Category(json_url=url)    try:        res = category.g    except Exception as e:        return abort(500)    if len(res) == 0:        return abort(404)    else:        return Response(res.serialize(format=&quot;turtle&quot;), mimetype=&quot;text/n3&quot;)#Ausgabe der RDF-Ontologie des IÖR@sora.route(&quot;/ontology&quot;, methods=['GET', 'POST'])def get_ontology():    dir = os.getcwd()    graph = Graph().parse(&quot;{}/app/sora/data/ontology.ttl&quot;.format(dir), format=&quot;turtle&quot;)    response = Response(graph.serialize(format=&quot;turtle&quot;), mimetype='text/n3')    response.headers['Access-Control-Allow-Origin'] = '*'    return response#Schnittstelle um die Esri-Geoprocessing Dienste zu nutzen@sora.route('/services', methods=['GET', 'POST'])def get():    job = request.args.get('job') or None    values = request.get_data() or None    job_id = request.args.get('job_id') or None    # test if JSON is valid    try:        # validate json        # set request and get response from esri server        request_handler = ESRIServerManager(job, values=values, job_id=job_id)        app.logger.debug(&quot;result:  n%s&quot;, str(request_handler.get_request()))        return request_handler.get_request()    except Exception as e:        if job == None:            return jsonify(error='no job query, API-Doku: https://ioer-dresden.github.io/monitor-api-doku/docs/sora')        else:            return InvalidUsage(e,status_code=410)# Error handling@sora.errorhandler(InvalidUsage)def handle_invalid_usage(error):    response = jsonify(error.to_dict())    response.status_code = error.status_code    return responseDa die Code Kommentare schon sehr gut wiedergeben was funktionale Betsandteile sindb g, soll nicht einzeln beschrieben werden was die instanziierten Klassen tun, dies ist nachfolgende dokumentiert.EsriServerManagerCodeDiese Klasse hat die Aufgabe anhand der übergebenen Job-ID den entsprechenden Service auf dem Esri-Server aufzurufen und das Ergebnis an den Clienten zu streamen. Treten dabei Fehler (Exceptions) auf oder ist die Anfrage durch den Clienten falsch formuliert, wird eine entsprechende Meldung als Response gesendet. Somit ist es dem Clienten möglich darauf zu reagieren.Esri-ServerGithubUm arcpy auf dem Server einzubinden, ist man auf einen ESRI-Server angewiesen. Alle Geo-Prozessing Services wurden in OOP-Python geschrieben und mit ArcMap getestet. Die Veröffentlichung eines Geo-Processing Services erfolgte nach der Offiziellen Anleitung.Abfrage von Indikatorwerten zu KoordinatenRest-APIMit diesem Service können für vorgegebene Koordinaten die jeweiligen Indikatorwerte abgefragt werden. Wird ein Bufferwert gesetzt, ermittelt der Service den Durchschnitt des Indikators innhalb des Buffer-Bereichs. Hierbei wird ein quadratische Buffer um jede Koordinate gesetzt, dessen Räumlicher Durchschnitt über den Paramter buffer gesetzt werden kann (siehe Paramter JSON). Aus diesem Buffer wird durch eine Umgebungsanalyse alle enthaltenen Pixelwerte ermittelt und deren Durchschnittliches Ergebnis an den Response für jede Koordinate angehangen. Nachfolgend ist für den Service das UML abgebildet:Anhand der Main-Methode wird ersichtlich, wie die vom TaskRepository aufgerufenen Methoden als Workflow dienen um das angefragte Ergebnis zu generieren.def main():    # ENV Settings    arcpy.env.overwriteOutput = 1    # how to round the values    round = 2    # the keys    indicators = &quot;indicators&quot;    indicator_id = &quot;id&quot;    year_id = &quot;year&quot;    buffer_id = &quot;buffer&quot;    # user input    input = json.loads(arcpy.GetParameterAsText(0))    task = Result(input,round)    for i in input[indicators]:        # settings        indicator = i[indicator_id]        year = i[year_id]        if i.has_key(&quot;buffer&quot;):            buffer = int(i[buffer_id])        else:            buffer = None        # create the result        task.getImagePath(indicator, year)        task.extractInput()        task.createPixelValues(buffer=buffer)    arcpy.SetParameterAsText(1,json.dumps(task.extractJSON()))Im ersten Schritt wird die in der Beschreibung der Rest-Schnittstelle doukumentierte JSON geparst und alle notwendigen Informationen aus dieser entnommen. Dann wird das entspreche GeoTIFF herausgesucht und der Pixelwert für jede Koordinate ermittelt. Ist ein Buffer gesetzt, wird für den gegebenen Indikator der entsprechende Wert ermittelt.Routing zwischen zwei KoordinatenRest-APIMit diesem Srvice kann die Lauf/Fahrdistanz zwischen zwei Koordinaten berechnet werden. Für die Berechnung der Distanz wird der Routing-Dienst Open Route Service eingesetzt, welcher von der Uni Heidelberg entwickelt wurde. Dieser Routing Dienst wird auf dem monitor.ioer.de Server lokal gehostet.Im ersten Schritt werdebn aus dem JSON-Request die notwendigen Paramter geparst. Dann müssen abweichende Koordinaten (der Open Route Service kann nur mit dem Koordinatensystem EPSG:4326 arbeiten) transformiert werden. Anschließend kann die Distanz bestimmt und ein Response gesendet werden.Routing zum nächstgelegenen POIRest-APIÄhnlich wie bei dem Service zur Bestimmung der Distanz zwischen zwei Kooridnaten, nutzt auch dieser WPS den Open Route Service um die Distanz zu berechnen. Jedoch werden in dem dokumentierten Dienst durch eine topographische-Umfeldanalyse die nähesten POI bestimmt und deren Distanz. Hierfür wurde eine Datenbank erstellt, welche zum jetzigen Zeitpunkt alle öffentlich zugänglichen Grünflächen und Haltestellten für den öffentlichen Nahverkehr in ganz Deutschland beinhalten. Auf dieser Grundlage kann nach der transformation der Koordnaten in das EPSG:4236 (falls nötig) für alle Koordinaten der näheste POI bestimmt werden. Dies ist mit der arcpy Funktion nearest Table erfolgt.ProblemeBei allen Diensten verusacht die Koordinatentransformation eine starke Verlangsamung des Rechenprozesses, was an arcpy liegt. Hierfür muss eine bessere Funktionalität gefunden werden. Leider ist man bei den ESRI-Servern auf arcpy angeweisen. Anbei der verantwortliche Code:def transformPoint(self,x, y, epsg_In, epsg_OUT):    point = arcpy.PointGeometry(arcpy.Point(x, y), arcpy.SpatialReference(epsg_In)).projectAs(        arcpy.SpatialReference(epsg_OUT))    return point.centroid",
    "url": "http://localhost:4000/monitor-api-doku/docs/sora",
    "relUrl": "/docs/sora"
  },
  "9": {
    "id": "9",
    "title": "User",
    "content": "UserDieser Blueprint dient der Nutzerverwaltung. Über einen generierten API-Key wird er in die Lage versetzt die OGC-Dienste des IÖR zu nutzen. Hierfür ist eine erstmalige Anmeldung notwendig. In diesem Kapitel werden alle Funktionalitäten und verwendete Technologien vorgestellt.",
    "url": "http://localhost:4000/monitor-api-doku/docs/user",
    "relUrl": "/docs/user"
  },
  "10": {
    "id": "10",
    "title": "Weiterentwicklung",
    "content": "Weiterentwicklung der APIIn diesem Kapitel wird die Weiterentwicklung der Monitor-API diskutiert, welche möglichen Aufgabe diese übernehmen kann und was noch verändert werden muss.      Aufsplitten der Blueprints  Durch die große Arbeitslast durch das SoRa-projekt sollte dieses in einen neuen Microservice gekapselt werden. Allegemein wäre zu überlegen ob nicht die API in Ihrer Gesamtheit aufgesplittet wird, in mehrere Microservices.      Einführung von OAuth  OAuth (Open Authorization) ist ein offenes Protokoll, das eine standardisierte, sichere API-Autorisierung für Desktop-, Web- und Mobile-Anwendungen erlaubt.QuelleMit der Verwendung dieser API wäre es möglich, die Nutzerverwaltung auch für den Monitor auszuweiten und dem angemeldeteten Nutzer spezifische Inhalte und Funktionen zu bieten.      Ausbau des Admin-Bereichs und OGC-Services  Im Moment ist es nur möglich einen Update der Dienste anzubieten. Perspektivisch wäre es auch wichtig die API um die REST-CRUD Methoden zu erweitern und diese in der GUI anzubieten.Ein weiterer Punkt wäre es, alle Aufgaben des IÖR-Monitor-Backends auf den Flask-Microservice zu übertragen und viele kleine Dienste zu orchestrieren.      Ablösen des alten MapServers durch Flask für die Rasterdarstellung des Monitors  Im Moment wird die Rasterdarstellung des IÖR-Monitors noch durch PHP5 durch Kombination mit einem veralteten MapServer auf einem anderen Server realisiert. Hierbei wird auch nur durch PHP ein Mapfile erstellt, welches die abgefragten Metadaten aus der MySQL Datenbank in das Mapfile schreibt. Diese Aufgabe kann auch die OGC-Factory übernehmen, welche auch einzelne Mapfiles schreiben kann. Hierfür muss die Methode createSingleService() des instanziierten WmsService aufgerufen und der gewünschte Pfad angegeben werden. Das erstellte Mapfile muss noch via CGI nach außen freigegeben und an den Monitor geschickt werden.",
    "url": "http://localhost:4000/monitor-api-doku/docs/weiterentwicklung.html",
    "relUrl": "/docs/weiterentwicklung.html"
  }
}
